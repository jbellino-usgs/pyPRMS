
from __future__ import (absolute_import, division, print_function)
from future.utils import iteritems

import glob
import os


class ValidParams(object):
    # Author: Parker Norton (pnorton@usgs.gov)
    # Create date: 2016-01-06
    # Description: Object for the database of valid input parameters

    def __init__(self, filename):
        # Mapping of certain parameters to their correct module
        self.__mod_map = {'hru_pansta': ['potet_pan'],
                          'tmin_adj': ['temp_1sta', 'temp_laps', 'ide_dist', 'xyz_dist'],
                          'tmax_adj': ['temp_1sta', 'temp_laps', 'ide_dist', 'xyz_dist'],
                          'hru_tsta': ['temp_1sta', 'temp_laps'],
                          'basin_tsta': ['temp_1sta', 'temp_laps', 'temp_dist2'],
                          'psta_elev': ['precip_laps', 'ide_dist', 'xyz_dist'],
                          'tsta_elev': ['temp_1sta', 'temp_laps', 'temp_dist2', 'ide_dist', 'xyz_dist'],
                          'elevlake_init': ['muskingum_lake'],
                          'gw_seep_coef': ['muskingum_lake'],
                          'lake_evap_adj': ['muskingum_lake'],
                          'lake_hru': ['muskingum_lake'],
                          'lake_hru_id': ['muskingum_lake'],
                          'lake_seep_elev': ['muskingum_lake'],
                          'lake_type': ['muskingum_lake']}

        self.__filename = filename
        self.__paramdb = None

        # TODO: need more robust logic here; currently no way to handle failures
        self.__isloaded = False
        self.__build_paramdb()
        self.__isloaded = True

    @property
    def filename(self):
        return self.__filename

    @filename.setter
    def filename(self, fname):
        self.__filename = fname

        self.__isloaded = False
        self.__build_paramdb()
        self.__isloaded = True

    @property
    def paramdb(self):
        return self.__paramdb

    def __build_paramdb(self):
        """Build the input parameter db from a collection of par_name files in a directory"""
        filelist = []

        if os.path.isfile(self.__filename):
            # A single input par_name file was specified
            filelist = [self.__filename]
        elif os.path.isdir(self.__filename):
            # A path containing multiple par_name files was specified
            filelist = [el for el in glob.glob('%s/*par_name*' % self.__filename)]

        thefirst = True

        for ff in filelist:
            if thefirst:
                self.__paramdb = self.__read_parname_file(ff)
                thefirst = False
            else:
                curr_dict = self.__read_parname_file(ff)

                # Add new control parameters or update module field for existing parameters
                for (kk, vv) in iteritems(curr_dict):
                    if kk in self.__paramdb:
                        # Control parameter already exists, check if this is a new module
                        if isinstance(self.__paramdb[kk]['Module'], list):
                            if vv['Module'][0] not in self.__paramdb[kk]['Module']:
                                self.__paramdb[kk]['Module'] += vv['Module']
                                # self.__paramdb[kk]['Module'].append(vv['Module'])
                        else:
                            if vv['Module'] != self.__paramdb[kk]['Module']:
                                # Convert Module entry to a list and add the new module name
                                tmp = self.__paramdb[kk]['Module']
                                self.__paramdb[kk]['Module'] = [tmp, vv['Module']]
                    else:
                        # We have a new control parameter
                        self.__paramdb[kk] = vv

    def __read_parname_file(self, fname):
        """Given a .par_name file (generated by prms -print) returns a dictionary
           of valid parameters. Returns None if file cannot be opened"""

        validparams = {}

        # Create parameter default ranges file from from PRMS -print results
        try:
            infile = open(fname, 'r')
        except IOError as err:
            print("Unable to open file\n", err)
            return None
        else:
            rawdata = infile.read().splitlines()
            infile.close()

            it = iter(rawdata)

            for line in it:
                if line == '--------------- PARAMETERS ---------------':
                    break

            toss_param = False  # Trigger for removing unwanted parameters

            for line in it:
                flds = line.split(':')

                if len(flds) < 2:
                    continue

                key = flds[0].strip()
                val = flds[1].strip()

                # Only need 'Name' and 'Module' information
                if key == 'Name':
                    if toss_param:
                        # Remove prior parameter if it was not wanted
                        del validparams[cparam]
                        toss_param = False

                    cparam = val  # Save parameter name for the remaining information
                    validparams[cparam] = {}
                elif key == 'Module':
                    if val == 'setup':
                        # Don't want to include parameters from the setup module
                        toss_param = True

                    # Override module(s) for select parameters
                    if cparam in self.__mod_map:
                        validparams[cparam][key] = self.__mod_map[cparam]
                    else:
                        validparams[cparam][key] = [val]
                elif key == 'Ndimen':
                    # Number of dimensions is superfluous; don't store
                    pass
                elif key == 'Dimensions':
                    # Get the dimension names; discard the sizes
                    dnames = [xx.split('-')[0].strip() for xx in val.split(',')]
                    validparams[cparam][key] = dnames
                elif key == 'Size':
                    # Don't need the total parameter size
                    pass
                elif key == 'Type':
                    cparam_type = val  # needed to convert max, min, and default values
                    validparams[cparam][key] = val
                elif key == 'Units':
                    if cparam_type == 'string':
                        # Units for strings are 'none'; no reason to store
                        pass
                elif key == 'Width':
                    # Width currently isn't populated
                    pass
                elif key in ['Max', 'Min', 'Default']:
                    if cparam_type == 'float':
                        validparams[cparam][key] = float(val)
                    elif cparam_type == 'long':
                        validparams[cparam][key] = int(val)
                    else:
                        validparams[cparam][key] = val
                else:
                    validparams[cparam][key] = val
        return validparams

    def get_param_subset(self, mods):
        """Return subset of paramdb based on selected modules"""
        subset = {}

        param_by_module = self.module_params(mods)

        for (cmod, params) in iteritems(param_by_module):
            for param in params:
                subset[param] = self.__paramdb[param]

        return subset

    def module_params(self, mod):
        # mod is a dictionary containing a single entry with format:
        #         key = a valid module name for any of vals
        #         val = one of [et_module, precip_module, solrad_module, srunoff_module,
        #               strmflow_module, temp_module, transp_module]

        params_by_module = {}

        # Build params by modules
        for (cmodname, val_mod) in iteritems(mod):
            # Can have one or more set
            for c_mod in val_mod:
                for (kk, vv) in iteritems(self.__paramdb):
                    if cmodname in vv['Module']:
                        if kk in ['potet_cbh_adj'] and cmodname == 'climate_hru' and c_mod != 'et_module':
                            # Only include potet_cbh_adj if et_module == climate_hru
                            continue

                        if cmodname not in params_by_module:
                            # Add new module entry
                            params_by_module[cmodname] = []

                        if kk not in params_by_module[cmodname]:
                            # Add new parameter name
                            params_by_module[cmodname].append(kk)
        return params_by_module
